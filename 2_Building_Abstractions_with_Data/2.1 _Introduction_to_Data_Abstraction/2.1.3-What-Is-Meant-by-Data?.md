2.1.3 O que se entende por dados?

Começamos a implementação do número racional na seção [2.1.1](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.1.1.html) através da implementação das operações de número racional add_rat, sub_rate assim por diante em termos de três funções não especificadas: make_rat, numer, e denom. Nesse ponto, poderíamos pensar nas operações como sendo definidas em termos de objetos de dados - numeradores, denominadores e números racionais - cujo comportamento foi especificado pelas últimas três funções.

Mas o que exatamente se entende por _dados_ ? Não é suficiente dizer tudo o que é implementado pelos seletores e construtores fornecidos. Claramente, nem todo conjunto arbitrário de três funções pode servir como uma base apropriada para a implementação do número racional. Precisamos garantir que, se construirmos um número racional a xpartir de um par de inteiros ne d, extrair o numere o denomde xe dividi-los deve produzir o mesmo resultado que dividir npor d. Em outras palavras, make_rat, numer, e denomtem de satisfazer a condição de que, para qualquer número inteiro ne qualquer diferente de zero inteiro d, se xé make_rat(n,d), em seguida, \ [\ frac {\ texttt {numer} (\ texttt {x})} {\ texttt {denom } (\ texttt {x})} = \ frac {\ texttt {n}} {\ texttt {d}} \]

Na verdade, esta é a única condição make_rat, numere denomdeve cumprir, de modo a formar uma base adequada para uma representação em número racional. Em geral, podemos pensar nos dados como definidos por alguma coleção de seletores e construtores, junto com as condições especificadas que essas funções devem cumprir para serem uma representação válida. [[1]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.1.3.html#footnote-1)

Este ponto de vista pode servir para definir não só alto nível objetos de dados, como números racionais, mas também objetos de nível inferior. Considere a noção de um par, que usamos para definir nossos números racionais. Nós nunca realmente disse o que um par era, apenas que a linguagem fornecido funções pair, heade tailpara operar em pares. Mas a única coisa que precisamos saber sobre essas três operações é que, se colarmos dois objetos usando pair, podemos recuperar os objetos usando heade tail. Ou seja, as operações satisfazem a condição de que, para quaisquer objetos xe y, se zé, pair(x, y)então head(z)é xe tail(z)éy. Na verdade, mencionamos que essas três funções são incluídas como primitivas em nossa linguagem. No entanto, qualquer tripla de funções que satisfaça a condição acima pode ser usada como base para a implementação de pares. Este ponto é ilustrado impressionante pelo fato de que nós poderíamos implementar pair, heade tailsem o uso de estruturas de dados em todos, mas usando apenas funções. Aqui estão as definições: [[2]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.1.3.html#footnote-2)

par de funções (x, y) {pair ( x , y ) { despacho de função (m) {despacho de função ( m ) { return m === 0 return m === 0 ? x? x : m === 1 : m === 1 ? y? y : erro (m, "argumento diferente de 0 ou 1 - par");: erro ( m , "argumento diferente de 0 ou 1 - par" ); }} envio de retorno; envio de retorno ; }} cabeça de função (z) { cabeça de função ( z ) { retornar z ( 0 ); } cauda da função ( z ) { retornar z ( 1 ); }

Esse uso de funções não corresponde a nada como nossa noção intuitiva de quais dados deveriam ser. No entanto, tudo o que precisamos fazer para mostrar que essa é uma forma válida de representar pares é verificar se essas funções satisfazem a condição dada acima.

O ponto sutil a notar é que o valor retornado por pair(x, y)é uma função - ou seja, a função definida internamente dispatch, que recebe um argumento e retorna xou ydependendo se o argumento é 0 ou 1. Correspondentemente, head(z)é definido para ser aplicado za 0. Portanto, se zfor a função formada por pair(x, y), então zaplicado a 0 resultará x. Assim, mostramos que head(pair(x, y))rende x, conforme desejado. Da mesma forma, tail(pair(x, y))aplica a função retornada por pair(x, y)a 1, que retorna y. Portanto, esta implementação funcional de pares é uma implementação válida, e se pares de acesso usando apenas pair, headetail não podemos distinguir esta implementação de outra que usa real estruturas de dados.

O objetivo de exibir a representação funcional de pares não é que nossa linguagem funcione dessa maneira (uma implementação eficiente de pares pode usar a estrutura de dados _vetoriais_ primitivos do JavaScript ), mas que pode funcionar dessa maneira. A representação funcional, embora obscura, é uma forma perfeitamente adequada de representar pares, pois atende às únicas condições que os pares precisam cumprir. Este exemplo também demonstra que a capacidade de manipular funções como objetos fornece automaticamente a capacidade de representar dados compostos. Isso pode parecer uma curiosidade agora, mas as representações funcionais de dados terão um papel central em nosso repertório de programação. Este estilo de programação é frequentemente chamado de _passagem de mensagens_, e iremos usá-lo como uma ferramenta básica no capítulo 3, quando abordarmos as questões de modelagem e simulação.

**Exercício 2.4** Aqui está uma representação funcional alternativa de pares. Para esta representação, verifique se head(pair(x, y))resulta xpara quaisquer objetos xe y.

par de funções ( x , y ) { return m => m ( x , y ); } cabeça de função ( z ) { return z (( p , q ) => p ); }

Qual é a definição correspondente de tail? (Dica: para verificar se isso funciona, faça uso do modelo de substituição da seção [1.1.5](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/1.1.5.html) .)

**Exercício 2.5** Mostre que podemos representar pares de inteiros não negativos usando apenas números e operações aritméticas se representarmos o par $ a $ e $ b $ como o inteiro que é o produto $ 2 ^ a 3 ^ b $. Dê as definições correspondentes das funções , e . uma

e b como o inteiro que é o produto 2uma3b. Dê as definições correspondentes das funções pairheadtail

**Exercício 2.6** No caso de representar pares como funções (exercício [2,4](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.1.3.html#ex_2.4) ) não foi incompreensível o suficiente, considere que, em uma linguagem que pode manipular funções, podemos sobreviver sem números (pelo menos no que diz respeito a inteiros não negativos) implementando 0 e a operação de adicionar 1 como

const zero = f => x => x ; função add_1 ( n ) { return f => x => f ( n ( f ) ( x )); }

Essa representação é conhecida como _numerais de Igreja_ , em _homenagem a_ seu inventor, Alonzo Church, o lógico que inventou o cálculo $ \ lambda $. Defina e diretamente (não em termos de e ). (Dica: Use substituição para avaliar ). Dê uma definição direta da função de adição (não em termos de aplicação repetida de ). λ

cálculo. Definir onetwozeroadd_1add_1(zero)plusadd_1

---

[[1]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.1.3.html#footnote-link-1) Surpreendentemente, essa ideia é muito difícil de formular com rigor. Existem duas abordagens para fornecer tal formulação. Um, lançado por CAR Hoare (1972), é conhecido como o método de _modelos abstratos_ . Formaliza o funções mais condições especificação conforme descrito no exemplo de número racional acima. Observe que a condição na representação do número racional foi declarada em termos de fatos sobre inteiros (igualdade e divisão). Em geral, os modelos abstratos definem novos tipos de objetos de dados em termos de tipos de objetos de dados previamente definidos. As afirmações sobre objetos de dados podem, portanto, ser verificadas reduzindo-as a afirmações sobre objetos de dados previamente definidos. Outra abordagem, introduzida por Zilles no MIT, por Goguen, Thatcher, Wagner e Wright na IBM (ver Thatcher, Wagner e Wright 1978 ), e por Guttag em Toronto (ver Guttag 1977 ), é chamado de _especificação algébrica_ . Diz respeito ao funções como elementos de um sistema algébrico abstrato, cujo comportamento é especificado por axiomas que correspondem ao nosso condições, e usa as técnicas de álgebra abstrata para verificar afirmações sobre objetos de dados. Ambos os métodos são examinados no artigo de Liskov e Zilles (1975).

[[2]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.1.3.html#footnote-link-2) A função errorintroduzida na seção [1.3.3](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/1.3.3.html) aceita como segundo argumento opcional uma string que é exibida antes do primeiro argumento, por exemplo, se mé 42:

Erro na linha 7: argumento diferente de 0 ou 1 - par: 42
