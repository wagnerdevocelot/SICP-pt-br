2.1.2 Barreiras de abstração

Antes de continuar com mais exemplos de dados compostos e abstração de dados, vamos considerar algumas das questões levantadas pelo exemplo do número racional. Definimos as operações com números racionais em termos de um construtor make_rate seletores numere denom. Em geral, a ideia subjacente da abstração de dados é identificar para cada tipo de objeto de dados um conjunto básico de operações em termos do qual todas as manipulações de objetos de dados desse tipo serão expressas e, em seguida, usar apenas essas operações na manipulação dos dados .

Podemos imaginar a estrutura do sistema de números racionais, conforme mostrado na figura [2,1](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.1.2.html#fig_2.1) . As linhas horizontais representam _barreiras de abstração_ que isolam diferentes níveis do sistema. Em cada nível, a barreira separa os programas (acima) que usam a abstração de dados dos programas (abaixo) que implementam a abstração de dados. Programas que usam números racionais os manipulam apenas em termos das funções fornecidas para uso público pelo pacote-número racional: add_rat, sub_rat, mul_rat, div_rat, e equal_rat. Estes, por sua vez, são implementadas apenas em termos do construtor e seletores make_rat, numere denom, que se forem implementadas em termos de pares. Os detalhes de como pares são implementadas são irrelevantes para o resto do pacote-número racional, desde que os pares podem ser manipulados pelo uso de pair, heade tail. Com efeito, as funções em cada nível são as interfaces que definem as barreiras de abstração e conectam os diferentes níveis.

![](https://source-academy.github.io/sicp/img_javascript/ch2-Z-G-6.svg)

**[Figura 2.1](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.1.2.html#fig_2.1)** Barreiras de abstração de dados no pacote de números racionais.

Essa ideia simples tem muitas vantagens. Uma vantagem é que torna os programas muito mais fáceis de manter e modificar. Qualquer estrutura de dados complexa pode ser representada de várias maneiras com as estruturas de dados primitivas fornecidas por uma linguagem de programação. Claro, a escolha da representação influencia os programas que operam nela; assim, se a representação fosse alterada em algum momento posterior, todos esses programas teriam que ser modificados de acordo. Essa tarefa pode ser demorada e cara no caso de programas grandes, a menos que a dependência da representação deva ser confinada por design a poucos módulos de programa.

Por exemplo, uma maneira alternativa de resolver o problema de reduzir os números racionais aos termos mais baixos é realizar a redução sempre que acessamos as partes de um número racional, em vez de quando o construímos. Isso leva a diferentes funções de construtor e seletor:

função make_rat (n, d) { make_rat(n, d) { par de retorno (n, d);return pair(n, d); }} função numer (x) {function numer(x) { const g = mdc (cabeça (x), cauda (x));const g = gcd(head(x), tail(x)); cabeça de retorno (x) / g;return head(x) / g; }} função denom (x) {function denom(x) { const g = mdc (cabeça (x), cauda (x));const g = gcd(head(x), tail(x)); retorno cauda (x) / g;return tail(x) / g; }}

A diferença entre esta implementação e a anterior está em quando calculamos o gcd. Se em nosso uso típico de números racionais acessamos os numeradores e denominadores dos mesmos números racionais muitas vezes, seria preferível calcular gcdquando os números racionais são construídos. Caso contrário, talvez seja melhor esperar até o tempo de acesso para calcular o gcd. Em qualquer caso, quando mudamos de uma representação para o outro, as funções add_rat, sub_rate assim por diante não tem que ser modificado em tudo.

Restringir a dependência da representação a algumas funções de interface nos ajuda a projetar programas, bem como a modificá-los, porque nos permite manter a flexibilidade para considerar implementações alternativas. Para continuar com nosso exemplo simples, suponha que estejamos projetando um pacote de números racionais e não podemos decidir inicialmente se vamos realizar o gcdno momento da construção ou no momento da seleção. A metodologia de abstração de dados nos dá uma maneira de adiar essa decisão sem perder a capacidade de fazer progresso no resto do sistema.

**Exercício 2.2** Considere o problema de representar segmentos de linha em um plano. Cada segmento é representado como um par de pontos: um ponto inicial e um ponto final. Declare um construtor make_segmente seletores start_segmente end_segmentque definam a representação dos segmentos em termos de pontos. Além disso, um ponto pode ser representado como um par de números: a coordenada $ x $ e a coordenada $ y $. Assim, especifique um construtor e seletores e que definam esta representação. Finalmente, usando seus seletores e construtores, declare uma função x

ymake_pointx_pointy_pointmidpoint_segmentque leva um segmento de linha como argumento e retorna seu ponto médio (o ponto cujas coordenadas são a média das coordenadas dos pontos finais). Para experimentar suas funções, você precisará de uma maneira de imprimir pontos:

function print_point (p) {print_point ( p ) { display de retorno ("(" + display de retorno ( "(" + stringify (x_point (p)) +( x_point ( p )) + "," +"," + stringify (y_point (p)) +( y_point ( p )) + ")");")" ); }}

**Exercício 2.3** Implemente uma representação para retângulos em um plano. (Dica: você pode querer fazer uso de exercícios [2,2](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.1.2.html#ex_2.2) .) Em termos de seus construtores e seletores, crie funções que calculam o perímetro e a área de um determinado retângulo. Agora implemente uma representação diferente para retângulos. Você pode projetar seu sistema com barreiras de abstração adequadas, de modo que as mesmas funções de perímetro e área funcionem usando qualquer uma das representações?
