2.5.3 Exemplo: Álgebra Simbólica

A manipulação de expressões algébricas simbólicas é um processo complexo que ilustra muitos dos problemas mais difíceis que ocorrem no projeto de sistemas de grande escala. Uma expressão algébrica, em geral, pode ser vista como uma estrutura hierárquica, uma árvore de operadores aplicada a operandos. Podemos construir expressões algébricas começando com um conjunto de objetos primitivos, como constantes e variáveis, e combinando-os por meio de operadores algébricos, como adição e multiplicação. Como em outras linguagens, formamos abstrações que nos permitem referir-nos a objetos compostos em termos simples. Abstrações típicas em álgebra simbólica são ideias como combinação linear, polinômio, função racional ou função trigonométrica. Podemos considerá-los compostos tipos, que geralmente são úteis para direcionar o processamento de expressões. Por exemplo, poderíamos descrever a expressão \ [x ^ {2} \, \ sin (y ^ 2 + 1) + x \, \ cos 2y + \ cos (y ^ 3 -2y ^ 2) \] como um polinômio em x

com coeficientes que são funções trigonométricas de polinômios em y

cujos coeficientes são inteiros.

Não tentaremos desenvolver um sistema de manipulação algébrica completo aqui. Esses sistemas são programas extremamente complexos, incorporando profundo conhecimento algébrico e algoritmos elegantes. O que faremos é examinar uma parte simples, mas importante, da manipulação algébrica: a aritmética dos polinômios. Ilustraremos os tipos de decisões que o designer de tal sistema enfrenta e como aplicar as idéias de dados abstratos e operações genéricas para ajudar a organizar esse esforço.

## Aritmética em polinômios

Nossa primeira tarefa ao projetar um sistema para realizar aritmética em polinômios é decidir o que é um polinômio. Os polinômios são normalmente definidos em relação a certas variáveis ​​(os _indeterminados_ do polinômio). Para simplificar, vamos nos restringir a polinômios com apenas um indeterminado _(polinômios univariados_ ). [[1]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-1)Definiremos um polinômio como uma soma de termos, cada um dos quais sendo um coeficiente, uma potência do indeterminado ou um produto de um coeficiente e uma potência do indeterminado. Um coeficiente é definido como uma expressão algébrica que não depende do indeterminado do polinômio. Por exemplo, \ [5x ^ 2 + 3x +7 \] é um polinômio simples em $ x $, e \ [(y ^ 2 +1) x ^ 3 + (2y) x + 1 \] é um polinômio em $ x $ cujos coeficientes são polinômios em $ y $.

5x2+ 3 x + 7

é um polinômio simples emx , e

(y2+ 1 )x3+ ( 2 anos) x + 1

é um polinômio emx cujos coeficientes são polinômios emy

.

Já estamos contornando alguns problemas espinhosos. O primeiro desses polinômios é o mesmo que o polinômio $ 5y ^ 2 + 3y + 7 $, ou não? Uma resposta razoável pode ser 5y2+ 3 anos+ 7

, ou não? Uma resposta razoável pode ser sim, se estivermos considerando um polinômio puramente como uma função matemática, mas não, se estivermos considerando um polinômio como uma forma sintática. O segundo polinômio é algebricamente equivalente a um polinômio em $ y $ cujos coeficientes são polinômios em $ x $. Nosso sistema deve reconhecer isso ou não? Além disso, existem outras maneiras de representar um polinômio - por exemplo, como um produto de fatores, ou (para um polinômio univariado) como o conjunto de raízes, ou como uma lista dos valores do polinômio em um conjunto especificado de pontos. [[2]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-2) Podemos refinar essas questões, decidindo que em nosso sistema de manipulação algébrica um cujos coeficientes são polinômios em x . Nosso sistema deve reconhecer isso ou não? Além disso, existem outras maneiras de representar um polinômio - por exemplo, como um produto de fatores, ou (para um polinômio univariado) como o conjunto de raízes, ou como uma lista dos valores do polinômio em um conjunto especificado de pontos.yx

[](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-2)polinomial será uma forma sintática particular, não seu significado matemático subjacente.

Agora devemos considerar como fazer aritmética em polinômios. Neste sistema simples, consideraremos apenas adição e multiplicação. Além disso, insistiremos que dois polinômios a serem combinados devem ter o mesmo indeterminado.

Abordaremos o design de nosso sistema seguindo a disciplina familiar de abstração de dados. Vamos representar polinômios usando uma estrutura de dados chamada _poli_ , que consiste em uma variável e uma coleção de termos. Assumimos que temos seletores variablee term_listque extraem essas partes de um poli e um construtor make_polyque monta um poli de uma determinada variável e uma lista de termos. Uma variável será apenas uma string, então podemos usar a is_same_variablefunção de seção [2.3.2](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.3.2.html) para comparar variáveis. As seguintes funções definem adição e multiplicação de polys:

function add_poly (p1, p2) {add_poly ( p1 , p2 ) { return is_same_variable (variable (p1), variable (p2))return is_same_variable ( variável ( p1 ), variável ( p2 )) ? make_poly (variável (p1),? make_poly ( variável ( p1 ), add_terms (term_list (p1),( term_list ( p1 ), term_list (p2)))( p2 ))) : erro (lista (p1, p2),: erro ( lista ( p1 , p2 ), "polys não estão na mesma var - add_poly");"polys não estão na mesma var - add_poly" ); }} function mul_poly (p1, p2) {function mul_poly ( p1 , p2 ) { return is_same_variable (variable (p1), variable (p2))return is_same_variable ( variável ( p1 ), variável ( p2 )) ? make_poly (variável (p1),? make_poly ( variável ( p1 ), mul_terms (term_list (p1),( term_list ( p1 ), term_list (p2)))( p2 ))) : erro (lista (p1, p2),: erro ( lista ( p1 , p2 ), "polys não estão no mesmo var - mul_poly");"polys não estão no mesmo var - mul_poly" ); }}

Para incorporar polinômios em nosso sistema aritmético genérico, precisamos fornecê-los com tags de tipo. Usaremos a tag "polynomial"e instalaremos as operações apropriadas em polinômios marcados na tabela de operação. Vamos embutir todo o nosso código em uma função de instalação para o pacote polinomial, semelhante aos da seção [2.5.1](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.1.html) : function install_polynomial_package() { // internal functions // representation of poly function make_poly(variable, term_list) { return pair(variable, term_list); } function variable(p) { return head(p); } function term_list(p) { return tail(p); } ⟨

_functions is_same_variable and is_variable from section 2.3.2_⟩ // representation of terms and term lists ⟨_functions adjoin_term...coeff from text below_⟩ function add*poly(p1, p2) { ... } ⟨\_functions used by add_poly*⟩ function mul*poly(p1, p2) { ... } ⟨\_functions used by mul_poly*⟩

// interface to rest of the system function tag(p) { return attach_tag("polynomial", p); } put("add", list("polynomial", "polynomial"), (p1, p2) => tag(add_poly(p1, p2))); put("mul", list("polynomial", "polynomial"), (p1, p2) => tag(mul_poly(p1, p2))); put("make", "polynomial", (variable, terms) => tag(make_poly(variable, terms))); return "done"; }

A adição polinomial é realizada a termo. Termos da mesma ordem (ou seja, com o mesmo poder do indeterminado) devem ser combinados. Isso é feito formando um novo termo da mesma ordem cujo coeficiente é a soma dos coeficientes dos adendos. Os termos em um adendo para os quais não há termos da mesma ordem no outro adendo são simplesmente acumulados no polinômio de soma que está sendo construído.

Para manipular listas de termos, assumiremos que temos um construtor the_empty_termlistque retorna uma lista de termos vazia e um construtor adjoin_termque adiciona um novo termo a uma lista de termos. Também assumiremos que temos um predicado is_empty_termlistque informa se uma determinada lista de termos está vazia, um seletor first_termque extrai o termo de ordem mais alta de uma lista de termos e um seletor rest_termsque retorna todos, exceto o termo de ordem mais alta. Para manipular os termos, vamos supor que temos um construtor make_termque constrói um termo com determinada ordem e coeficiente, e seletores orderecoeffque retornam, respectivamente, a ordem e o coeficiente do termo. Essas operações nos permitem considerar ambos os termos e listas de termos como abstrações de dados, cujas representações concretas podemos nos preocupar separadamente.

Aqui está a função que constrói a lista de termos para a soma de dois polinômios; [[3]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-3) observe que estendemos ligeiramente a sintaxe das declarações condicionais descritas na seção [1.3.2](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/1.3.2.html) admitindo outra declaração condicional no lugar do seguinte bloco else:

function add_terms (L1, L2) {add_terms ( L1 , L2 ) { if (is_empty_termlist (L1)) {if ( is_empty_termlist ( L1 )) { return L2;return L2 ; } else if (is_empty_termlist (L2)) {} else if ( is_empty_termlist ( L2 )) { return L1;return L1 ; } senão {} else { const t1 = primeiro_termo (L1);const t1 = primeiro_termo ( L1 ); const t2 = primeiro_termo (L2);const t2 = primeiro_termo ( L2 ); pedido de retorno (t1)> pedido (t2)pedido de retorno ( t1 ) > pedido ( t2 ) ? adjoin_term (t1, add_terms (rest_terms (L1), L2))? adjoin_term ( t1 , add_terms ( rest_terms ( L1 ), L2 )) : pedido (t1) <pedido (t2): pedido ( t1 ) < pedido ( t2 ) ? adjoin_term (t2, add_terms (L1, rest_terms (L2)))? adjoin_term ( t2 , add_terms ( L1 , rest_terms ( L2 ))) : adjoin_term (make_term (order (t1), : adjoin_term ( make_term ( order ( t1 ), adicione (coeficiente (t1),( coeficiente ( t1 ), coeficiente (t2))),( t2 ))), add_terms (rest_terms (L1),( rest_terms ( L1 ), rest_terms (L2)));( L2 ))); }} }}

O ponto mais importante a notar aqui é que usamos a função de adição genérica addpara somar os coeficientes dos termos que estão sendo combinados. Isso tem consequências poderosas, como veremos a seguir.

Para multiplicar duas listas de termos, multiplicamos cada termo da primeira lista por todos os termos da outra lista, repetidamente usando mul_term_by_all_terms, que multiplica um determinado termo por todos os termos em uma determinada lista de termos. As listas de termos resultantes (uma para cada termo da primeira lista) são acumuladas em uma soma. Multiplicar dois termos forma um termo cuja ordem é a soma das ordens dos fatores e cujo coeficiente é o produto dos coeficientes dos fatores:

function mul_terms (L1, L2) {mul_terms ( L1 , L2 ) { return is_empty_termlist (L1)return is_empty_termlist ( L1 ) ? the_empty_termlist? the_empty_termlist : add_terms (mul_term_by_all_terms (: add_terms ( mul_term_by_all_terms ( primeiro_term (L1), L2),( L1 ), L2 ), mul_terms (rest_terms (L1), L2));( rest_terms ( L1 ), L2 )); }} function mul_term_by_all_terms (t1, L) {function mul_term_by_all_terms ( t1 , L ) { if (is_empty_termlist (L)) {if ( is_empty_termlist ( L )) { return the_empty_termlist;return the_empty_termlist ; } senão {} else { const t2 = primeiro_termo (L);const t2 = primeiro_termo ( L ); return adjoin_term (return adjoin_term ( make_term (pedido (t1) + pedido (t2),( pedido ( t1 ) + pedido ( t2 ), mul (coeficiente (t1), coeficiente (t2))),( coeff ( t1 ), coeff ( t2 ))), mul_term_by_all_terms (t1, rest_terms (L)));( t1 , rest_terms ( L ))); }} }}

Isso é realmente tudo que há para adição e multiplicação de polinômios. Observe que, como operamos em termos usando as funções genéricas adde mul, nosso pacote polinomial é automaticamente capaz de lidar com qualquer tipo de coeficiente conhecido pelo pacote aritmético genérico. Se incluirmos um mecanismo de coerção, como um dos discutidos na seção [2.5.2](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html) , então também podemos lidar automaticamente com operações em polinômios de diferentes tipos de coeficientes, como \ [{\ left [3x ^ 2 + (2 + 3i) x + 7 \ right] \ cdot \ left [x ^ 4 + \ frac {2} {3} x ^ 2 + (5 + 3i) \ direita]} \]

[ 3x2+ ( 2 + 3 i ) x + 7 ] ⋅ [x4+23x2+ ( 5 + 3 i ) ]

Como instalamos as funções de adição e multiplicação polinomial add_polye mul_polyno sistema aritmético genérico como as operações adde mulpara o tipo polynomial, nosso sistema também é automaticamente capaz de lidar com operações polinomiais como \ [{\ left [(y + 1) x ^ 2 + ( y ^ 2 +1) x + (y-1) \ right] \ cdot \ left [(y-2) x + (y ^ 3 +7) \ right]} \] A razão é que quando o sistema tenta combinar coeficientes , ele será enviado para e . Uma vez que os próprios coeficientes são polinômios (em $ y $), eles serão combinados usando e . O resultado é uma espécie de

[ ( y+ 1 )x2+ (y2+ 1 ) x + ( y- 1 ) ] ⋅ [ ( y- 2 ) x + (y3+ 7 ) ]

A razão é que quando o sistema tenta combinar coeficientes, ele irá despachar addmuly

), eles serão combinados usando add_polymul_poly recursão dirigida por dados em que, por exemplo, uma chamada para mul_polyresultará em chamadas recursivas para a mul_polyfim de multiplicar os coeficientes. Se os coeficientes dos coeficientes fossem eles próprios polinômios (como podem ser usados ​​para representar polinômios em três variáveis), a direção dos dados garantiria que o sistema seguiria por outro nível de chamadas recursivas, e assim por diante por tantos níveis quanto a estrutura de os dados ditam. [[4]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-4)

## Representando listas de termos

Finalmente, devemos enfrentar o trabalho de implementação de uma boa representação para listas de termos. Uma lista de termos é, na verdade, um conjunto de coeficientes codificados pela ordem do termo. Portanto, qualquer um dos métodos para representar conjuntos, conforme discutido na seção [2.3.3](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.3.3.html) , pode ser aplicado a esta tarefa. Por outro lado, nossas funções add_termse mul_termssempre acessam listas de termos sequencialmente, da ordem mais alta para a mais baixa. Assim, usaremos algum tipo de representação de lista ordenada.

Como devemos estruturar a lista que representa uma lista de termos? Uma consideração é a densidade dos polinômios que pretendemos manipular. Um polinômio é considerado _denso_ se tiver coeficientes diferentes de zero em termos da maioria das ordens. Se tiver muitos termos zero, é considerado _esparso_ . Por exemplo, \ [A: \ quad x ^ 5 + 2x ^ 4 + 3x ^ 2 -2x -5 \] é um polinômio denso, enquanto \ [B: \ quad x ^ {100} + 2x ^ 2 +1 \ ] é esparso.

R :x5+ 2x4+ 3x2- 2 x - 5

é um polinômio denso, enquanto

B :x100+ 2x2+ 1

é esparso.

A lista de termos de um polinômio denso é mais eficientemente representada como uma lista de coeficientes. Por exemplo, $ A $ acima seria bem representado como . A ordem de um termo nesta representação é o comprimento da sublista começando com o coeficiente desse termo, diminuído em 1. [[5]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-5) Esta seria uma representação terrível para um polinômio esparso como $ B $: haveria uma lista gigante de zeros pontuados por alguns termos diferentes de zero solitários. Uma representação mais razoável da lista de termos de um polinômio esparso é como uma lista de termos diferentes de zero, onde cada termo é uma lista contendo a ordem do termo e o coeficiente para essa ordem. Nesse esquema, o polinômio $ B $ é eficientemente representado comoUMA

acima seria bem representado como list(1, 2, 0, 3, -2, -5)[](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-5)B: Haveria uma lista gigante de zeros pontuada por alguns termos diferentes de zero solitários. Uma representação mais razoável da lista de termos de um polinômio esparso é como uma lista de termos diferentes de zero, onde cada termo é uma lista contendo a ordem do termo e o coeficiente para essa ordem. Em tal esquema, polinômioB

é eficientemente representado como list(list(100, 1), list(2, 2), list(0, 1)). Como a maioria das manipulações polinomiais é realizada em polinômios esparsos, usaremos este método. Assumiremos que as listas de termos são representadas como listas de termos, organizadas dos termos de ordem mais alta para os de ordem mais baixa. Depois de tomarmos essa decisão, a implementação dos seletores e construtores de termos e listas de termos é simples: [[6]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-6)

função adjoin_term ( termo , term_list ) { return is_equal_to_zero ( coeff ( termo )) ? term_list : par ( term , term_list ); } const the_empty_termlist = null ; função first_term ( term_list ) { return head ( term_list ); } função rest_terms ( term_list ) { cauda de retorno ( term_list ); } function is_empty_termlist ( term_list ) { return is_null ( term_list ); } função make_term ( ordem , coeficiente ) { lista de retorno ( ordem , coeficiente ); } ordem de função ( termo ) { cabeçalho de retorno ( termo ); } função coeff ( term ) { return head ( tail ( term )); }

onde is_equal_to_zeroé como definido no exercício [2,80](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.1.html#ex_2.80) . (Veja também exercício [2,87](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#ex_2.87) abaixo de.)

Os usuários do pacote polinomial criarão polinômios (marcados) por meio da função:

função make_polynomial ( variável , termos ) { return get ( "make" , "polinomial" ) ( variável , termos ); }

**Exercício 2.87** Instale is_equal_to_zeropara polinômios no pacote aritmético genérico. Isso permitirá adjoin_termtrabalhar com polinômios com coeficientes que são eles próprios polinômios.

**Exercício 2.88** Estenda o sistema polinomial para incluir a subtração de polinômios. (Dica: você pode achar útil definir uma operação de negação genérica.)

**Exercício 2.89** Declare funções que implementam a representação da lista de termos descrita acima conforme apropriado para polinômios densos.

**Exercício 2.90** Suponha que queiramos ter um sistema polinomial que seja eficiente para polinômios esparsos e densos. Uma maneira de fazer isso é permitir os dois tipos de representações de lista de termos em nosso sistema. A situação é análoga ao exemplo de número complexo da seção [2,4](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.4.html) , onde permitimos representações retangulares e polares. Para fazer isso, devemos distinguir os diferentes tipos de listas de termos e tornar genéricas as operações nas listas de termos. Redesenhe o sistema polinomial para implementar essa generalização. Este é um grande esforço, não uma mudança local.

**Exercício 2.91** Um polinômio univariado pode ser dividido por outro para produzir um quociente polinomial e um resto polinomial. Por exemplo, \ [\ frac {x ^ 5-1} {x ^ 2 -1} = x ^ 3 + x, \ text {resto} x-1 \] Divisão pode ser realizada por meio de divisão longa. Ou seja, divida o termo de ordem mais alta do dividendo pelo termo de ordem mais alta do divisor. O resultado é o primeiro termo do quociente. Em seguida, multiplique o resultado pelo divisor, subtraia-o do dividendo e produza o resto da resposta dividindo recursivamente a diferença pelo divisor. Pare quando a ordem do divisor exceder a ordem do dividendo e declare que o dividendo é o restante. Além disso, se o dividendo chegar a zero, retorne zero como quociente e resto.

x5- 1x2- 1=x3+ x , resto x - 1

A divisão pode ser realizada por meio de divisão longa. Ou seja, divida o termo de ordem mais alta do dividendo pelo termo de ordem mais alta do divisor. O resultado é o primeiro termo do quociente. Em seguida, multiplique o resultado pelo divisor, subtraia-o do dividendo e produza o resto da resposta dividindo recursivamente a diferença pelo divisor. Pare quando a ordem do divisor exceder a ordem do dividendo e declare que o dividendo é o restante. Além disso, se o dividendo chegar a zero, retorne zero como quociente e resto.

Podemos projetar uma div_polyfunção no modelo de add_polye mul_poly. A função verifica se os dois pólos têm a mesma variável. Nesse caso, div_polyremove a variável e passa o problema para div_terms, que realiza a operação de divisão nas listas de termos. A função div_polyfinalmente anexa novamente a variável ao resultado fornecido por div_terms. É conveniente projetar div_termspara calcular o quociente e o restante de uma divisão. A função div_termspode receber duas listas de termos como argumentos e retornar uma lista da lista de termos de quociente e a lista de termos restantes.

Complete a seguinte definição de div*termspreenchendo as expressões ausentes. Use para implementar div_poly, que recebe dois polys como argumentos e retorna uma lista do quociente e polys do resto. function div_terms(L1, L2) { if (is_empty_termlist(L1)) { return list(the_empty_termlist, the_empty_termlist); } else { const t1 = first_term(L1); const t2 = first_term(L2); if (order(t2) > order(t1)) { return list(the_empty_termlist, L1); } else { const new_c = div(coeff(t1), coeff(t2)); const new_o = order(t1) - order(t2); const rest_of_result = ⟨\_compute rest of result recursively*⟩; ⟨_form complete result_⟩ } } }

## Hierarquias de tipos em álgebra simbólica

Nosso sistema polinomial ilustra como objetos de um tipo (polinômios) podem de fato ser objetos complexos que possuem objetos de muitos tipos diferentes como partes. Isso não apresenta nenhuma dificuldade real na definição de operações genéricas. Precisamos apenas instalar operações genéricas apropriadas para realizar as manipulações necessárias das partes dos tipos compostos. Na verdade, vimos que os polinômios formam uma espécie de abstração de dados recursiva, em que as partes de um polinômio podem ser polinômios. Nossas operações genéricas e nosso estilo de programação direcionado a dados podem lidar com essa complicação sem muitos problemas.

Por outro lado, álgebra polinomial é um sistema para o qual os tipos de dados não podem ser organizados naturalmente em uma torre. Por exemplo, é possível ter polinômios em $ x $ cujos coeficientes são polinômios em $ y $. Também é possível ter polinômios em $ y $ cujos coeficientes são polinômios em $ x $. Nenhum desses tipos é x

cujos coeficientes são polinômios em y. Também é possível ter polinômios emy cujos coeficientes são polinômios em x

. Nenhum desses tipos é acima de o outro de qualquer maneira natural, mas muitas vezes é necessário somar elementos de cada conjunto. Existem várias maneiras de fazer isso. Uma possibilidade é converter um polinômio no tipo do outro expandindo e reorganizando os termos de modo que ambos os polinômios tenham a mesma variável principal. Pode-se impor uma estrutura semelhante a uma torre ordenando as variáveis ​​e, portanto, sempre convertendo qualquer polinômio em um Forma canônica com a variável de prioridade mais alta dominante e as variáveis ​​de prioridade mais baixa enterradas nos coeficientes. Essa estratégia funciona muito bem, exceto que a conversão pode expandir um polinômio desnecessariamente, tornando-o difícil de ler e talvez menos eficiente de trabalhar. A estratégia da torre certamente não é natural para este domínio ou para qualquer domínio em que o usuário possa inventar novos tipos dinamicamente usando tipos antigos em várias formas de combinação, como funções trigonométricas, séries de potência e integrais.

Não deveria ser surpreendente que controlar a coerção seja um problema sério no projeto de sistemas de manipulação algébrica em larga escala. Grande parte da complexidade de tais sistemas diz respeito às relações entre diversos tipos. Na verdade, é justo dizer que ainda não entendemos completamente a coerção. Na verdade, ainda não entendemos completamente o conceito de tipo de dados. No entanto, o que sabemos nos fornece princípios poderosos de estruturação e modularidade para apoiar o projeto de grandes sistemas.

**Exercício 2.92** Ao impor uma ordem às variáveis, estenda o pacote polinomial de forma que a adição e a multiplicação de polinômios funcionem para polinômios em variáveis ​​diferentes. (Isso não é fácil!)

## Exercício estendido: funções racionais

Podemos estender nosso sistema aritmético genérico para incluir _funções racionais_ . Estes são frações cujo numerador e denominador são polinômios, como \ [\ frac {x + 1} {x ^ 3 -1} \] O sistema deve ser capaz de adicionar, subtrair, multiplicar e dividir funções racionais e realizar cálculos como \ [\ frac {x + 1} {x ^ 3 -1} + \ frac {x} {x ^ 2 -1} = \ frac {x ^ 3 + 2x ^ 2 + 3x +1} {x ^ 4 + x ^ 3 -x-1} \] (Aqui a soma foi simplificada removendo fatores comuns. Ordinário

x + 1x3- 1

O sistema deve ser capaz de adicionar, subtrair, multiplicar e dividir funções racionais e realizar cálculos como

x + 1x3- 1+xx2- 1=x3+ 2x2+ 3 x + 1x4+x3- x - 1

(Aqui, a soma foi simplificada removendo fatores comuns. Comum multiplicação cruzada teria produzido um polinômio de quarto grau sobre um polinômio de quinto grau.)

Se modificarmos nosso pacote aritmético racional para que ele use operações genéricas, ele fará o que queremos, exceto pelo problema de reduzir as frações aos termos mais baixos.

**Exercício 2.93** Modifique o pacote aritmético racional para usar operações genéricas, mas mude make_ratpara que ele não tente reduzir as frações aos termos mais baixos. Teste seu sistema chamando make_rationaldois polinômios para produzir uma função racional

const p1 = make_polynomial ( "x" , lista ( make_term ( 2 , 1 ), make_term ( 0 , 1 ))); const p2 = make_polynomial ( "x" , lista ( make_term ( 3 , 1 ), make_term ( 0 , 1 ))); const rf = make_rational ( p2 , p1 );

Agora adicione rfa si mesmo, usando add. Você observará que esta função de adição não reduz as frações aos termos mais baixos.

Podemos reduzir as frações polinomiais aos termos mais baixos usando a mesma ideia que usamos com inteiros: modificar make_ratpara dividir o numerador e o denominador pelo seu maior divisor comum. A noção de maior divisor comum faz sentido para polinômios. Na verdade, podemos calcular o GCD de dois polinômios usando essencialmente o mesmo Algoritmo de Euclides que funciona para inteiros. [[7]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-7) A versão inteira é

função gcd ( a , b ) { return b === 0 ? a : mdc ( b , a % b ); }

Usando isso, poderíamos fazer a modificação óbvia para definir uma operação GCD que funcione em listas de termos:

function gcd_terms ( a , b ) { return is_empty_termlist ( b ) ? a : gcd_terms ( b , remainder_terms ( a , b )); }

onde remainder_termsseleciona o componente restante da lista retornada pela operação de divisão da lista de termos div_termsque foi implementada no exercício [2,91](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#ex_2.91) .

**Exercício 2.94** Usando div_terms, implemente a função remainder_termse use-a para definir gcd_termscomo acima. Agora escreva uma função gcd_polyque calcule o GCD polinomial de dois polys. (A função deve sinalizar um erro se os dois polis não estiverem na mesma variável.) Instale no sistema uma operação genérica greatest_common_divisorque reduz a gcd_polypara polinômios e ordinária gcdpara números comuns. Como um teste, tente

const p1 = make_polynomial ( "x" , list ( make_term ( 4 , 1 ), make_term ( 3 , - 1 ), make_term ( 2 , - 2 ), make_term ( 1 , 2 ))); const p2 = make_polynomial ( "x" , lista ( make_term ( 3 , 1 ), make_term ( 1 , - 1 ))); greatest_common_divisor ( p1 , p2 );

e verifique o seu resultado manualmente.

**Exercício 2.95** Defina $ P* {1} $, $ P* {2} $ e $ P\_ {3} $ como os polinômios P1

, P2, e P3 ser os polinômios

$ P\_ {1} $: P1

:

$ x ^ 2 - 2x + 1 $ x2- 2 x + 1

$ P\_ {2} $: P2

:

$ 11x ^ 2 + 7 $ 11x2+ 7

$ P\_ {3} $: P3

:

$ 13x + 5 $ 13 x + 5

Agora defina $ Q_1 $ como o produto de $ P_1 $ e $ P_2 $ e $ Q_2 $ como o produto de $ P_1 $ e $ P_3 $, e use (exercício Q1 ser o produto de P1 e P2 e Q2 ser o produto de P1 e P3, E use greatest_common_divisor [2,94](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#ex_2.94) ) para calcular o GCD de $ Q_1 $ e $ Q_2 $. Observe que a resposta não é a mesma que $ P_1 $. Este exemplo introduz operações não inteiras na computação, causando dificuldades com o algoritmo GCD. [[8]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-8) Para entender o que está acontecendo, tente rastrear enquanto calcula o GCD ou tente realizar a divisão manualmente. Q1 e Q2. Observe que a resposta não é a mesma queP1. Este exemplo introduz operações não inteiras na computação, causando dificuldades com o algoritmo GCD. [](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-8)gcd_terms

Podemos resolver o problema exibido no exercício [2,95](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#ex_2.95) se usarmos a seguinte modificação do algoritmo GCD (que realmente funciona apenas no caso de polinômios com coeficientes inteiros). Antes de realizar qualquer divisão polinomial no cálculo do GCD, multiplicamos o dividendo por um fator constante inteiro, escolhido para garantir que nenhuma fração surgirá durante o processo de divisão. Nossa resposta, portanto, será diferente do GCD real por um fator constante de número inteiro, mas isso não importa no caso de reduzir as funções racionais aos termos mais baixos; o GCD será usado para dividir o numerador e o denominador, de forma que o fator da constante inteira será cancelado.

Mais precisamente, se $ P $ e $ Q $ são polinômios, seja $ O*1 $ da ordem de $ P $ (ou seja, a ordem do maior termo de $ P $) e seja $ O_2 $ da ordem de $ Q $. Seja $ c $ o coeficiente líder de $ Q $. Então pode ser mostrado que, se multiplicarmos $ P $ pelo \_fator de integerização* $ c ^ {1 + O* {1} -O* {2}} $, o polinômio resultante pode ser dividido por $ Q $ usando o algoritmo sem introduzindo quaisquer frações. A operação de multiplicação do dividendo por essa constante e então a divisão é às vezes chamada de _pseudodivisão_ de $ P $ por $ Q $. O restante da divisão é chamado de _pseudoremainder_ .P

e Q são polinômios, vamos O1 seja a ordem de P (ou seja, a ordem do maior termo de P) e deixar O2 seja a ordem de Q. Deixarc ser o principal coeficiente de Q. Então, pode ser mostrado que, se multiplicarmosP pelo c1 +O1-O2, o polinômio resultante pode ser dividido por Q usando o div_termsP de Q

. O restante da divisão é chamado de

**Exercício 2.96**

1.  Implemente a função pseudoremainder_terms, que é remainder_termsigual, exceto que ela multiplica o dividendo pelo fator de integração descrito acima antes de chamar div_terms. Modifique gcd_termspara usar pseudoremainder_termse verifique se greatest_common_divisoragora produz uma resposta com coeficientes inteiros no exemplo do exercício [2,95](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#ex_2.95) .
2.  O GCD agora tem coeficientes inteiros, mas eles são maiores do que $ P_1 $. Modifique para que ele remova fatores comuns dos coeficientes da resposta, dividindo todos os coeficientes por seu maior divisor comum (inteiro).P1

3.  . Modificargcd_terms

Assim, aqui está como reduzir uma função racional aos termos mais baixos:

- Calcule o GCD do numerador e denominador, usando a versão gcd_termsdo exercício [2,96](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#ex_2.96) .
- Ao obter o GCD, multiplique o numerador e o denominador pelo mesmo fator de integerização antes de dividir pelo GCD, de modo que a divisão pelo GCD não introduza coeficientes não inteiros. Como fator, você pode usar o coeficiente líder do GCD elevado à potência $ 1 + O* {1} -O* {2} $, onde $ O* {2} $ é a ordem do GCD e $ O* {1} $ é o máximo das ordens do numerador e denominador. Isso garantirá que a divisão do numerador e do denominador pelo GCD não introduzirá nenhuma fração.1 +O1-O2

, Onde O2 é a ordem do GCD e O1

- é o máximo das ordens do numerador e denominador. Isso garantirá que a divisão do numerador e do denominador pelo GCD não introduzirá nenhuma fração.
- O resultado desta operação será um numerador e denominador com coeficientes inteiros. Os coeficientes normalmente serão muito grandes por causa de todos os fatores de integerização, então a última etapa é remover os fatores redundantes calculando o maior divisor comum (inteiro) de todos os coeficientes do numerador e do denominador e dividindo por este fator .

**Exercício 2.97**

1.  Implementar este algoritmo como uma função reduce_termsque leva duas listas prazo ne dcomo argumentos e retorna uma lista nn, ddque são ne dreduzidos a termos mais baixo via o algoritmo dado acima. Escreva também uma função reduce_poly, análoga a add_poly, que verifica se os dois polys têm a mesma variável. Em caso afirmativo, reduce_polyremove a variável e passa o problema para reduce_terms, em seguida, anexa novamente a variável às duas listas de termos fornecidas por reduce_terms.
2.  Defina uma função análoga reduce_termsàquela que faz o que o original make_ratfazia para inteiros:

    função reduzir_integers ( n , d ) { const g = mdc ( n , d ); lista de retorno ( n / g , d / g ); }

    e define reducecomo uma operação genérica que chama apply_genericpara despachar para reduce_poly(para polynomialargumentos) ou reduce_integers(para javascript_numberargumentos). Agora você pode facilmente fazer com que o pacote da aritmética racional reduza as frações aos termos mais baixos, fazendo uma make_ratchamada reduceantes de combinar o numerador e o denominador fornecidos para formar um número racional. O sistema agora lida com expressões racionais em números inteiros ou polinômios. Para testar seu programa, experimente o exemplo no início deste exercício extenso:

    const p1 = make_polynomial ( "x" , lista ( make_term ( 1 , 1 ), make_term ( 0 , 1 ))); const p2 = make_polynomial ( "x" , lista ( make_term ( 3 , 1 ), make_term ( 0 , - 1 ))); const p3 = make_polynomial ( "x" , lista ( make_term ( 1 , 1 ))); const p4 = make_polynomial ( "x" , lista ( make_term ( 2 , 1 ), make_term ( 0 , - 1 ))); const rf1 = make_rational ( p1 , p2 ); const rf2 = make_rational ( p3 , p4 ); adicionar ( rf1 , rf2 );

    Veja se obteve a resposta correta, reduzida corretamente aos termos mais baixos.

A computação GCD está no centro de qualquer sistema que execute operações em funções racionais. O algoritmo usado acima, embora matematicamente simples, é extremamente lento. A lentidão se deve em parte ao grande número de operações de divisão e em parte ao enorme tamanho dos coeficientes intermediários gerados pelas pseudodivisões. Uma das áreas ativas no desenvolvimento de sistemas de manipulação algébrica é o projeto de melhores algoritmos para computar GCDs polinomiais. [[9]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-9)

---

[[1]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-link-1) Por outro lado, permitiremos polinômios cujos coeficientes são eles próprios polinômios em outras variáveis. Isso nos dará essencialmente o mesmo poder de representação de um sistema multivariado completo, embora leve a problemas de coerção, conforme discutido abaixo.

[[2]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-link-2) Para polinômios univariados, fornecer o valor de um polinômio em um determinado conjunto de pontos pode ser uma representação particularmente boa. Isso torna a aritmética polinomial extremamente simples. Para obter, por exemplo, a soma de dois polinômios representados dessa forma, precisamos apenas adicionar os valores dos polinômios nos pontos correspondentes. Para transformar de volta a uma representação mais familiar, podemos usar a fórmula de interpolação de Lagrange, que mostra como recuperar os coeficientes de um polinômio de grau $ n $ dados os valores do polinômio em $ n + 1 $ pontos. n

dados os valores do polinômio em n + 1

pontos.

[[3]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-link-3) Esta operação é muito parecida com a union_setoperação ordenada que desenvolvemos no exercício [2,62](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.3.3.html#ex_2.62) . Na verdade, se pensarmos nos termos do polinômio como um conjunto ordenado de acordo com a potência do indeterminado, então o programa que produz a lista de termos para uma soma é quase idêntico a union_set.

[[4]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-link-4) Para tornar este trabalho completamente tranquilo, devemos também adicionar ao nosso sistema aritmético genérico a capacidade de coagir um número a um polinômio, considerando-o como um polinômio de grau zero cujo coeficiente é o número. Isso é necessário se vamos realizar operações como \ [{\ left [x ^ 2 + (y + 1) x + 5 \ right] + \ left [x ^ 2 + 2x + 1 \ right]} \] que requer a adição do coeficiente $ y + 1 $ ao coeficiente 2.

[x2+ ( y+ 1 ) x + 5 ] + [x2+2x+1]

que requer a adição do coeficiente y+1

ao coeficiente 2.

[[5]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-link-5) Nestes exemplos polinomiais, assumimos que implementamos o sistema aritmético genérico usando o mecanismo de tipo sugerido no exercício [2,78](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.1.html#ex_2.78) . Assim, os coeficientes que são números comuns serão representados como os próprios números, em vez de pares cuja headstring é "javascript_number".

[[6]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-link-6) Embora estejamos assumindo que as listas de termos são ordenadas, implementamos adjoin_termpara simplesmente combinar o novo termo com a lista de termos existente usando pair. Podemos nos safar com isso, contanto que garantamos que as funções (como add_terms) que usam adjoin_termsempre o chamem com um termo de ordem superior do que aparece na lista. Se não quiséssemos fazer tal garantia, poderíamos ter implementado adjoin_termpara ser semelhante ao adjoin_setconstrutor para a representação de lista ordenada de conjuntos (exercício [2,61](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.3.3.html#ex_2.61) )

[[7]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-link-7) O fato de o Algoritmo de Euclides funcionar para polinômios é formalizado na álgebra, dizendo que os polinômios formam uma espécie de domínio algébrico chamado _anel euclidiano_ . Um anel euclidiano é um domínio que admite adição, subtração e multiplicação comutativa, juntamente com uma forma de atribuir a cada elemento $ x $ do anel um número inteiro positivo x

do anel um número inteiro positivo medir $ m (x) $ com as propriedades que $ m (xy) \ geq m (x) $ para qualquer $ x $ diferente de zero e $ y $ e que, dados quaisquer $ x $ e $ y $, existe um $ q $ tal que $ y = qx + r $ e $ r = 0 $ ou $ m (r) <m (x) $. De um ponto de vista abstrato, isso é o que é necessário para provar que o Algoritmo de Euclides funciona. Para o domínio de inteiros, a medida $ m $ de um inteiro é o valor absoluto do próprio inteiro. Para o domínio dos polinômios, a medida de um polinômio é o seu grau. m(x) com as propriedades que m(xy)≥m(x) para qualquer diferente de zero x e y e isso, dado qualquer x e y, existe um q de tal modo que y=qx+r e também r=0 ou m(r)<m(x). De um ponto de vista abstrato, isso é o que é necessário para provar que o Algoritmo de Euclides funciona. Para o domínio de inteiros, a medidam

de um inteiro é o valor absoluto do próprio inteiro. Para o domínio dos polinômios, a medida de um polinômio é o seu grau.

[[8]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-link-8) Em JavaScript, a divisão de inteiros pode produzir números decimais de precisão limitada e, portanto, podemos falhar em obter um divisor válido.

[[9]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.3.html#footnote-link-9) Um método extremamente eficiente e elegante para calcular GCDs polinomiais foi descoberto por Richard Zippel (1979). O método é um algoritmo probabilístico, assim como o teste rápido de primalidade que discutimos no capítulo 1. O livro de Zippel (1993) descreve esse método, junto com outras maneiras de calcular GCDs polinomiais.
