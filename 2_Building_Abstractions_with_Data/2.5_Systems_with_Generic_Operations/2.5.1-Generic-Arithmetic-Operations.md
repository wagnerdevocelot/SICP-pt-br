2.5.1 Operações Aritméticas Genéricas

A tarefa de projetar operações aritméticas genéricas é análoga à de projetar as operações de números complexos genéricos. Gostaríamos, por exemplo, de ter uma função de adição genérica addque atue como adição primitiva +comum em números comuns, como add_ratem números racionais e como add_complexem números complexos. Podemos implementar add, e as outras operações aritméticas genéricas, seguindo a mesma estratégia que usamos na seção [2.4.3](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.4.3.html) para implementar os seletores genéricos para números complexos. Vamos anexar uma tag de tipo a cada tipo de número e fazer com que a função genérica seja despachada para um pacote apropriado de acordo com o tipo de dados de seus argumentos.

As funções aritméticas genéricas são definidas da seguinte forma:

function add (x, y) {add ( x , y ) { retornar apply_generic ("adicionar", list (x, y));retornar apply_generic ( "adicionar" , list ( x , y )); }} function sub (x, y) {function sub ( x , y ) { retornar apply_generic ("sub", list (x, y));retornar apply_generic ( "sub" , list ( x , y )); }} function mul (x, y) {function mul ( x , y ) { retornar apply_generic ("mul", list (x, y));retornar apply_generic ( "mul" , list ( x , y )); }} função div (x, y) {função div ( x , y ) { retornar apply_generic ("div", list (x, y));retornar apply_generic ( "div" , list ( x , y )); }}

Começamos instalando um pacote para lidar _com_ números _comuns_ , ou seja, os números primitivos de nossa linguagem. Iremos etiquetá-los com a string "javascript_number". As operações aritméticas neste pacote são as funções aritméticas primitivas (portanto, não há necessidade de definir funções extras para lidar com os números não marcados). Uma vez que cada uma dessas operações leva dois argumentos, elas são instaladas na tabela codificada pela lista list("javascript_number", "javascript_number"):

function install_javascript_number_package () {install_javascript_number_package () { tag de função (x) {tag de função ( x ) { return attach_tag ("javascript_number", x);return attach_tag ( "javascript_number" , x ); }} put ("add", list ("javascript_number", "javascript_number"), ( "add" , list ( "javascript_number" , "javascript_number" ), (x, y) => tag (x + y));( x , y ) => tag ( x + y )); put ("sub", list ("javascript_number", "javascript_number"), ( "sub" , list ( "javascript_number" , "javascript_number" ), (x, y) => tag (x - y));( x , y ) => tag ( x - y )); put ("mul", list ("javascript_number", "javascript_number"), ( "mul" , list ( "javascript_number" , "javascript_number" ), (x, y) => tag (x _ y));( x , y ) => tag ( x _ y )); put ("div", list ("javascript_number", "javascript_number"), ( "div" , list ( "javascript_number" , "javascript_number" ), (x, y) => tag (x / y));( x , y ) => tag ( x / y )); put ("make", "javascript_number", ( "make" , "javascript_number" , x => tag (x));=> tag ( x )); retornar "pronto";retornar "pronto" ; }}

Os usuários do pacote de número JavaScript criarão números comuns (marcados) por meio da função:

function make_javascript_number (n) {make_javascript_number ( n ) { return get ("make", "javascript_number") (n);return get ( "make" , "javascript_number" ) ( n ); }}

Agora que a estrutura do sistema aritmético genérico está estabelecida, podemos incluir prontamente novos tipos de números. Aqui está um pacote que executa aritmética racional. Observe que, como um benefício da aditividade, podemos usar sem modificação o código de número racional da seção [2.1.1](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.1.1.html) como as funções internas no pacote:

function install_rational_package () {install_rational_package () { // funções internas// funções internas função numer (x) {função numer ( x ) { cabeça de retorno (x);cabeça de retorno ( x ); }} função denom (x) {função denom ( x ) { return tail (x);return tail ( x ); }} função make_rat (n, d) {função make_rat ( n , d ) { const g = mdc (n, d);const g = mdc ( n , d ); par de retorno (n / g, d / g);par de retorno ( n / g , d / g ); }} function add_rat ( x , y ) { retornar make_rat ( numer ( x ) _ denom ( y ) + numer ( y ) _ denom ( x ), denom ( x ) _ denom ( y )); } function sub_rat ( x , y ) { retornar make_rat ( numer ( x ) _ denom ( y ) - numer ( y ) _ denom ( x ), denom ( x ) _ denom ( y )); } function mul_rat ( x , y ) { retornar make_rat ( numer ( x ) _ numer ( y ), denom ( x ) _ denom ( y )); } function div_rat ( x , y ) { retornar make_rat ( numer ( x ) _ denom ( y ), denom ( x ) _ numer ( y )); } // interface com o resto do sistema tag de função ( x ) { return attach_tag ( "racional" , x ); } put ( "adicionar" , listar ( "racional" , "racional" ), ( x , y ) => tag ( add_rat ( x , y ))); put ( "sub" , lista ( "racional" , "racional" ), ( x , y ) => tag ( sub_rat ( x , y ))); put ( "mul" , lista ( "racional" , "racional" ), ( x , y ) => tag ( mul_rat ( x , y ))); colocar ( "div" , list ( "racional" , "racional" ), ( x , y ) => tag ( div_rat ( x , y ))); colocar ( "fazer" , "racional" , ( n , d ) => tag ( make_rat ( n , d ))); retornar "pronto" ; } função make_rational ( n , d ) { return get ( "make" , "rational" ) ( n , d ); }

Podemos instalar um pacote semelhante para lidar com números complexos, usando a tag "complex". Na criação do pacote, extraímos da tabela as operações make_from_real_image make_from_mag_angque foram definidas pelos pacotes retangulares e polares. Aditividade nos permite usar, como as operações internas, as mesmas add_complex, sub_complex, mul_complex, e div_complexfunções de seção [2.4.1](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.4.1.html) .

function install_complex_package () { // funções importadas de pacotes retangulares e polares function make_from_real_imag ( x , y ) { return get ( "make_from_real_imag" , "rectangular" ) ( x , y ); } função make_from_mag_ang ( r , a ) { return get ( "make_from_mag_ang" , "polar" ) ( r , a ); } // funções internas funcionar add_complex ( Z1 , Z2 ) { retorno make_from_real_imag ( real_part ( Z1 ) + real_part ( Z2 ), imag_part ( Z1 ) + imag_part ( z2 )); } função sub_complex ( z1 , z2 ) { return make_from_real_imag ( real_part ( z1 ) - parte_real ( z2 ), parte_imagem ( z1 ) - parte_imagem ( z2 )); } função mul_complex ( z1 , z2 ) { retornar make_from_mag_ang ( magnitude ( z1 ) \* magnitude ( z2 ), ângulo ( z1 ) + ângulo ( z2 )); } função div_complex ( z1 , z2 ) { return make_from_mag_ang ( magnitude ( z1 ) / magnitude ( z2 ), ângulo ( z1 ) - ângulo ( z2 )); } // interface com o resto da tag de função do sistema ( z ) { return attach_tag ( "complex" , z ); } put ( "add" , list ( "complex" , "complex" ), ( z1 , z2 ) => tag ( add_complex ( z1 , z2 ))); put ( "sub" , lista ( "complexo" , "complexo" ),( z1 , z2 ) => tag ( sub_complex ( z1 , z2 ))); put ( "mul" , lista ( "complexo" , "complexo" ), ( z1 , z2 ) => tag ( mul_complex ( z1 , z2 ))); put ( "div" , list ( "complex" , "complex" ), ( z1 , z2 ) => tag ( div_complex ( z1 , z2 ))); put ( "make_from_real_imag" , "complex" , ( x , y ) => tag ( make_from_real_imag ( x , y ))); put ( "make_from_mag_ang" , "complex" , ( r , a ) => tag ( make_from_mag_ang ( r , a ))); retornar "pronto" ; }

Programas fora do pacote de números complexos podem construir números complexos a partir de partes reais e imaginárias ou de magnitudes e ângulos. Observe como as funções subjacentes, originalmente definidas nos pacotes retangulares e polares, são exportadas para o pacote complexo e de lá para o mundo externo.

função make_complex_from_real_imag ( x , y ) { return get ( "make_from_real_imag" , "complex" ) ( x , y ); } função make_complex_from_mag_ang ( r , a ) { return get ( "make_from_mag_ang" , "complex" ) ( r , a ); }

O que temos aqui é um sistema de tags de dois níveis. Um número complexo típico, como $ 3 + 4i $ na forma retangular, seria representado como mostrado na figura 3 + 4 i

na forma retangular, seria representado como mostrado na figura [2,24](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.1.html#fig_2.24) . A tag externa ( "complex") é usada para direcionar o número ao pacote complexo. Uma vez dentro do pacote complexo, a próxima tag ( "rectangular") é usada para direcionar o número para o pacote retangular. Em um sistema grande e complicado, pode haver muitos níveis, cada um conectado com o próximo por meio de operações genéricas. Conforme um objeto de dados é passado para baixo, a etiqueta externa que é usada para direcioná-lo para o pacote apropriado é removida (aplicando contents) e o próximo nível da etiqueta (se houver) torna-se visível para ser usado para envio posterior.![](https://source-academy.github.io/sicp/img_javascript/ch2-Z-G-65.svg)

![](https://source-academy.github.io/sicp/img_javascript/ch2-Z-G-65.svg)

**[Figura 2.24](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.1.html#fig_2.24)** Representação de $ 3 + 4i $ na forma retangular. 3 + 4 i

em forma retangular.

Nos pacotes acima, usamos add_rat, add_complexe as outras funções aritméticas exatamente como originalmente escrito. Uma vez que estas declarações são internos para diferentes funções de instalação, no entanto, eles não nomes necessidade mais longos que são distintos entre si: nós poderíamos simplesmente nomeá-los add, sub, mul, e divem ambos os pacotes.

**Exercício 2.77** Louis Reasoner tenta avaliar a expressão magnitude(z)onde zestá o objeto mostrado na figura [2,24](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.1.html#fig_2.24) . Para sua surpresa, em vez da resposta $ 5 $, ele recebe uma mensagem de erro dizendo que não há método para a operação nos tipos . Ele mostra essa interação para Alyssa P. Hacker, que diz 5

ele recebe uma mensagem de erro de apply_genericmagnitudelist("complex") O problema é que os seletores de "complex"números complexos nunca foram definidos para números, apenas para números "polar"e "rectangular". Tudo que você precisa fazer para que isso funcione é adicionar o seguinte ao complexpacote:

put ( "parte_real" , lista ( "complexo" ), parte_real ); put ( "imag_part" , list ( "complex" ), imag_part ); put ( "magnitude" , lista ( "complexo" ), magnitude ); colocar ( "ângulo" , lista ( "complexo" ), ângulo );

Descreva em detalhes por que isso funciona. Como exemplo, rastreie todas as funções chamadas na avaliação da expressão magnitude(z)onde zestá o objeto mostrado na figura [2,24](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.1.html#fig_2.24) . Em particular, quantas vezes é apply_genericinvocado? Para qual função é enviada em cada caso?

**Exercício 2.78** As funções internas no javascript_numberpacote são, essencialmente, nada mais do que chamadas para as funções primitivas +, -etc. Não foi possível usar as primitivas da linguagem diretamente porque o nosso sistema de tag tipo requer que cada objeto de dados têm um tipo ligado a isto. Na verdade, no entanto, todas as implementações de JavaScript têm um sistema de tipos, que usam internamente. Predicados primitivos como is_stringe is_numberdeterminam se os objetos de dados têm tipos específicos. Modificar as definições de type_tag, contentse attach_tagda secção [2.4.2](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.4.2.html) para que nosso sistema genérico aproveite o sistema de tipo interno do JavaScript. Ou seja, o sistema deve funcionar como antes, exceto que os números comuns devem ser representados simplesmente como números JavaScript, em vez de pares cuja headstring é "javascript_number".

**Exercício 2.79** Defina um predicado de igualdade genérico is_equalque testa a igualdade de dois números e instale-o no pacote aritmético genérico. Esta operação deve funcionar para números comuns, números racionais e números complexos.

**Exercício 2.80** Defina um predicado genérico is_equal_to_zeroque testa se seu argumento é zero e instale-o no pacote aritmético genérico. Esta operação deve funcionar para números comuns, números racionais e números complexos.
