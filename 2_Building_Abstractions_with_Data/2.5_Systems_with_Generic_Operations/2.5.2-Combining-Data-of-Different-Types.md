2.5.2 Combinando Dados de Tipos Diferentes

Vimos como definir um sistema aritmético unificado que engloba números comuns, números complexos, números racionais e qualquer outro tipo de número que possamos decidir inventar, mas ignoramos uma questão importante. As operações que definimos até agora tratam os diferentes tipos de dados como sendo completamente independentes. Assim, existem pacotes separados para adicionar, digamos, dois números comuns ou dois números complexos. O que ainda não consideramos é o fato de que é significativo definir operações que cruzam os limites de tipo, como a adição de um número complexo a um número comum. Esforçamo-nos muito para introduzir barreiras entre as partes dos nossos programas, para que pudessem ser desenvolvidos e compreendidos separadamente. Gostaríamos de apresentar as operações de tipo cruzado de uma forma cuidadosamente controlada,para que possamos apoiá-los sem violar seriamente os limites do módulo.

Uma maneira de lidar com operações de tipo cruzado é projetar uma função diferente para cada combinação possível de tipos para os quais a operação é válida. Por exemplo, poderíamos estender o pacote de números complexos de modo que forneça uma função para adicionar números complexos a números comuns e instalar isso na tabela usando a tag list("complex", "javascript_number"): [[1]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#footnote-1)

// a ser incluído na função de pacote complexo add_complex_to_javascript_num ( z , x ) { return make_complex_from_real_imag ( real_part ( z ) + x , imag_part ( z )); } put ( "add" , list ( "complex" , "javascript_number" ), ( z , x ) => tag ( add_complex_to_javascript_num ( z , x )));

Essa técnica funciona, mas é complicada. Com tal sistema, o custo da introdução de um novo tipo não é apenas a construção do pacote de funções para aquele tipo, mas também a construção e instalação das funções que implementam as operações de tipo cruzado. Isso pode facilmente ser muito mais código do que o necessário para definir as operações no próprio tipo. O método também prejudica nossa capacidade de combinar pacotes separados aditivamente, ou pelo menos limitar a extensão em que os implementadores de pacotes individuais precisam levar em conta outros pacotes. Por exemplo, no exemplo acima, parece razoável que lidar com operações mistas em números complexos e números comuns seja responsabilidade do pacote de números complexos. Combinar números racionais e números complexos, no entanto, pode ser feito pelo pacote complexo,pelo pacote racional, ou por algum terceiro pacote que usa operações extraídas desses dois pacotes. Formular políticas coerentes sobre a divisão de responsabilidades entre os pacotes pode ser uma tarefa árdua no projeto de sistemas com muitos pacotes e muitas operações de tipo cruzado.

## Coerção

Na situação geral de operações completamente não relacionadas agindo em tipos completamente não relacionados, a implementação de operações explícitas de tipo cruzado, por mais complicada que seja, é o melhor que se pode esperar. Felizmente, geralmente podemos fazer melhor aproveitando a estrutura adicional que pode estar latente em nosso sistema de tipos. Freqüentemente, os diferentes tipos de dados não são completamente independentes e pode haver maneiras pelas quais os objetos de um tipo podem ser vistos como sendo de outro tipo. Este processo é chamado de _coerção_. Por exemplo, se formos solicitados a combinar aritmeticamente um número comum com um número complexo, podemos ver o número comum como um número complexo cuja parte imaginária é zero. Isso transforma o problema em combinar dois números complexos, que podem ser tratados da maneira comum pelo pacote aritmético complexo.

Em geral, podemos implementar essa ideia projetando funções de coerção que transformam um objeto de um tipo em um objeto equivalente de outro tipo. Aqui está uma função de coerção típica, que transforma um determinado número comum em um número complexo com aquela parte real e zero parte imaginária:

function javascript_number_to_complex ( n ) { return make_complex_from_real_imag ( contents ( n ), 0 ); }

Instalamos essas funções de coerção em uma tabela de coerção especial, indexada sob os nomes dos dois tipos:

put_coercion ( "javascript_number" , "complex" , javascript_number_to_complex );

(Presumimos que existem funções put_coercione get_coerciondisponíveis para manipular esta tabela.) Geralmente, alguns dos slots na tabela estarão vazios, porque geralmente não é possível coagir um objeto de dados arbitrário de cada tipo em todos os outros tipos. Por exemplo, não há como forçar um número complexo arbitrário a um número comum, portanto, não haverá complex_to_javascript_numberfunção geral incluída na tabela.

Uma vez que a tabela de coerção foi configurada, podemos lidar com a coerção de maneira uniforme, modificando a apply_genericfunção da seção [2.4.3](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.4.3.html) . Quando solicitados a aplicar uma operação, primeiro verificamos se a operação está definida para os tipos de argumentos, assim como antes. Nesse caso, despachamos para a função encontrada na tabela de operação e tipo. Caso contrário, tentamos a coerção. Para simplificar, consideramos apenas o caso em que existem dois argumentos. [[2]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#footnote-2) Verificamos a tabela de coerção para ver se objetos do primeiro tipo podem ser coagidos para o segundo tipo. Nesse caso, forçamos o primeiro argumento e tentamos a operação novamente. Se os objetos do primeiro tipo não podem, em geral, ser coagidos para o segundo tipo, tentamos a coerção ao contrário para ver se há uma maneira de coagir o segundo argumento ao tipo do primeiro argumento. Finalmente, se não houver uma maneira conhecida de coagir um dos tipos ao outro, desistimos. Aqui está a função:

função apply_generic ( op , args ) { const type_tags = map ( type_tag , args ); const fun = get ( op , type_tags ); if (! is_undefined ( fun )) { return apply ( fun , map ( contents , args )); } else { if ( length ( args ) === 2 ) { const type1 = head ( type_tags ); const type2 = head ( tail ( type_tags )); const a1 = cabeça ( args ); const a2 = cabeça ( cauda ( args )); const t1_to_t2 = get_coercion ( tipo1 , tipo2 ); const t2_to_t1 = get_coercion ( type2 , type1 ); volte ! is_undefined ( t1_to_t2 ) ? apply_generic ( op , lista ( t1_to_t2 ( a1 ), a2 )) : ! is_undefined ( t2_to_t1 ) ? apply_generic ( op , list ( a1 , t2_to_t1 ( a2 ))) : erro ( list ( op , type_tags ), "nenhum método para esses tipos" ); } else { return error ( list ( op , type_tags ), "nenhum método para esses tipos" ); } } }

Esse esquema de coerção tem muitas vantagens sobre o método de definição de operações explícitas de tipo cruzado, conforme descrito acima. Embora ainda precisemos escrever funções de coerção para relacionar os tipos (possivelmente $ n ^ 2 $ funções para um sistema com $ n $ tipos), precisamos escrever apenas uma função para cada par de tipos em vez de uma função diferente para cada coleção de tipos e cada operação genérica. [[3]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#footnote-3) O que contamos aqui é o fato de que a transformação apropriada entre os tipos depende apenas dos próprios tipos, não da operação a ser aplicada.n2

n

Por outro lado, pode haver aplicações para as quais nosso esquema de coerção não seja geral o suficiente. Mesmo quando nenhum dos objetos a serem combinados pode ser convertido para o tipo do outro, ainda pode ser possível realizar a operação convertendo ambos os objetos em um terceiro tipo. Para lidar com tamanha complexidade e ainda preservar a modularidade em nossos programas, normalmente é necessário construir sistemas que aproveitem ainda mais a estrutura nas relações entre os tipos, como discutiremos a seguir.

## Hierarquias de tipos

O esquema de coerção apresentado acima baseava-se na existência de relações naturais entre pares de tipos. Freqüentemente, há mais global estrutura em como os diferentes tipos se relacionam entre si. Por exemplo, suponha que estejamos construindo um sistema aritmético genérico para lidar com inteiros, números racionais, números reais e números complexos. Em tal sistema, é bastante natural considerar um número inteiro como um tipo especial de número racional, que por sua vez é um tipo especial de número real, que por sua vez é um tipo especial de número complexo. O que realmente temos é uma chamada _hierarquia de tipos_ , na qual, por exemplo, inteiros são um _subtipo_ de números racionais (ou seja, qualquer operação que pode ser aplicada a um número racional pode ser aplicada automaticamente a um inteiro). Por outro lado, dizemos que os números racionais formam um _supertipo_de inteiros. A hierarquia particular que temos aqui é de um tipo muito simples, em que cada tipo tem no máximo um supertipo e no máximo um subtipo. Essa estrutura, chamada de \_torre_ , é ilustrada na figura [2,25](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#fig_2.25) . ![](https://source-academy.github.io/sicp/img_original/ch2-Z-G-66.svg)

![](https://source-academy.github.io/sicp/img_original/ch2-Z-G-66.svg)

**[Figura 2.25](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#fig_2.25)** Uma torre de tipos.

Se tivermos uma estrutura de torre, então podemos simplificar muito o problema de adicionar um novo tipo à hierarquia, pois precisamos apenas especificar como o novo tipo é incorporado no próximo supertipo acima dele e como é o supertipo do tipo abaixo isto. Por exemplo, se quisermos adicionar um inteiro a um número complexo, não precisamos definir explicitamente uma função de coerção especial integer_to_complex. Em vez disso, definimos como um número inteiro pode ser transformado em um número racional, como um número racional é transformado em um número real e como um número real é transformado em um número complexo. Em seguida, permitimos que o sistema transforme o inteiro em um número complexo por meio dessas etapas e, a seguir, adicionamos os dois números complexos.

Podemos redesenhar nossa apply_genericfunção da seguinte maneira: Para cada tipo, precisamos fornecer uma raisefunção, que levanta objetos desse tipo um nível na torre. Então, quando o sistema é necessário para operar em objetos de diferentes tipos, ele pode elevar sucessivamente os tipos inferiores até que todos os objetos estejam no mesmo nível na torre. (Exercícios [2,83](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#ex_2.83) e [2,84](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#ex_2.84) dizem respeito aos detalhes de implementação de tal estratégia.)

Outra vantagem de uma torre é que podemos facilmente implementar a noção de que todo tipo herda todas as operações definidas em um supertipo. Por exemplo, se não fornecermos uma função especial para encontrar a parte real de um inteiro, devemos, no entanto, esperar que real_partseja definida para inteiros em virtude do fato de que inteiros são um subtipo de números complexos. Em uma torre, podemos fazer com que isso aconteça de maneira uniforme, modificando apply_generic. Se a operação necessária não for definida diretamente para o tipo de objeto fornecido, elevamos o objeto ao seu supertipo e tentamos novamente. Assim, subimos pela torre, transformando nosso argumento à medida que avançamos, até encontrar um nível em que a operação desejada possa ser realizada ou chegar ao topo (nesse caso, desistimos).

Outra vantagem de uma torre sobre uma hierarquia mais geral é que ela nos dá uma maneira simples de diminuir um objeto de dados para a representação mais simples. Por exemplo, se adicionarmos $ 2 + 3i $ a $ 4-3i $, seria bom obter a resposta como o inteiro 6 em vez de como o número complexo $ 6 + 0i $. Exercício 2 + 3 i

para 4 - 3 i, seria bom obter a resposta como o inteiro 6 em vez de como o número complexo 6 + 0 i. Exercício [2,85](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#ex_2.85) discute uma maneira de implementar essa operação de abaixamento. (O truque é que precisamos de uma maneira geral de distinguir os objetos que podem ser abaixados, como $ 6 + 0i $, daqueles que não podem, como $ 6 + 2i $.)6 + 0 i, daqueles que não podem, como 6 + 2 i

.) ![](https://source-academy.github.io/sicp/img_original/ch2-Z-G-67.svg)

![](https://source-academy.github.io/sicp/img_original/ch2-Z-G-67.svg)

**[Figura 2.26](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#fig_2.26)** Relações entre tipos de figuras geométricas.

## Inadequações de hierarquias

Se os tipos de dados em nosso sistema podem ser organizados naturalmente em uma torre, isso simplifica muito os problemas de lidar com operações genéricas em tipos diferentes, como vimos. Infelizmente, esse geralmente não é o caso. Figura [2,26](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#fig_2.26) ilustra um arranjo mais complexo de tipos mistos, mostrando relações entre diferentes tipos de figuras geométricas. Vemos que, em geral, um tipo pode ter mais de um subtipo. Triângulos e quadriláteros, por exemplo, são subtipos de polígonos. Além disso, um tipo pode ter mais de um supertipo. Por exemplo, um triângulo retângulo isósceles pode ser considerado um triângulo isósceles ou um triângulo retângulo. Esse problema de supertipos múltiplos é particularmente espinhoso, pois significa que não há uma maneira única de levantar um tipo na hierarquia. Encontrando o correto O supertipo no qual aplicar uma operação a um objeto pode envolver uma pesquisa considerável em toda a rede de tipo por parte de uma função como apply_generic. Uma vez que geralmente existem vários subtipos para um tipo, há um problema semelhante ao forçar um valor baixa a hierarquia de tipo. Lidar com um grande número de tipos inter-relacionados e ainda preservar a modularidade no projeto de grandes sistemas é muito difícil e é uma área de muita pesquisa atual. [[4]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#footnote-4)

**Exercício 2.81** Louis Reasoner notou que apply_genericpodem tentar coagir os argumentos um ao outro, mesmo que eles já tenham o mesmo tipo. Portanto, ele raciocina, precisamos colocar funções na tabela de coerção para coagir argumentos de cada tipo para seu próprio tipo. Por exemplo, além da javascript_number_to_complexcoerção mostrada acima, ele faria:

function javascript_number_to_javascript_number ( n ) { return n ; } função complex_to_complex ( n ) { retornar n ; } put_coercion ( "javascript_number" , "javascript_number" , javascript_number_to_javascript_number ); put_coercion ( "complexo" , "complexo" , complexo_para_complex );

1.  Com as funções de coerção de Louis instaladas, o que acontece se apply_genericfor chamado com dois argumentos do tipo "javascript_number"ou dois argumentos do tipo "complex"para uma operação que não é encontrada na tabela para esses tipos? Por exemplo, suponha que definimos uma operação de exponenciação genérica:

    função exp ( x , y ) { return apply_generic ( "exp" , list ( x , y )); }

    e colocaram uma função de exponenciação no pacote JavaScript-number, mas não em qualquer outro pacote:

    // seguinte adicionado ao pacote de número JavaScript put ( "exp" , list ( "javascript_number" , "javascript_number" ), ( x , y ) => tag ( math_exp ( x , y ))); // usando math_exp primitiva

    O que acontece se chamarmos expcom dois números complexos como argumentos?

2.  Louis está correto ao dizer que algo precisava ser feito a respeito da coerção com argumentos do mesmo tipo, ou apply_genericfunciona corretamente como está?
3.  Modifique apply_genericpara que não tente coerção se os dois argumentos tiverem o mesmo tipo.

**Exercício 2.82** Mostre como generalizar apply_genericpara lidar com a coerção no caso geral de argumentos múltiplos. Uma estratégia é tentar coagir todos os argumentos para o tipo do primeiro argumento, depois para o tipo do segundo argumento, e assim por diante. Dê um exemplo de situação em que essa estratégia (e da mesma forma a versão com dois argumentos fornecida acima) não seja suficientemente geral. (Dica: considere o caso em que existem algumas operações de tipo misto adequadas presentes na tabela que não serão tentadas.)

**Exercício 2.83** Suponha que você esteja projetando um sistema aritmético genérico para lidar com os tipos de torre mostrados na figura [2,25](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#fig_2.25) : inteiro, racional, real, complexo. Para cada tipo (exceto complexo), projete uma função que eleve objetos daquele tipo um nível na torre. Mostre como instalar uma raiseoperação genérica que funcionará para cada tipo (exceto complexo).

**Exercício 2.84** Usando a raiseoperação do exercício [2,83](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#ex_2.83) , modifique a apply_genericfunção para que ela coage seus argumentos a terem o mesmo tipo pelo método de aumento sucessivo, conforme discutido nesta seção. Você precisará desenvolver uma maneira de testar qual dos dois tipos está mais alto na torre. Faça isso de uma maneira que seja compatível com o resto do sistema e não levará a problemas na adição de novos níveis à torre.

**Exercício 2.85** Esta seção mencionou um método para simplificando um objeto de dados abaixando-o na torre de tipos, tanto quanto possível. Projete uma função dropque realize isso para a torre descrita no exercício [2,83](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#ex_2.83) . A chave é decidir, de uma maneira geral, se um objeto pode ser abaixado. Por exemplo, o número complexo $ 1,5 + 0i $ pode ser diminuído tanto quanto , o número complexo $ 1 + 0i $ pode ser reduzido até , e o número complexo $ 2 + 3i $ não pode ser diminuído de forma alguma. Aqui está um plano para determinar se um objeto pode ser abaixado: Comece definindo uma operação genérica que 1,5 + 0 i

"real"1 + 0 i"integer"2 + 3 iproject empurra um objeto na torre. Por exemplo, projetar um número complexo envolveria jogar fora a parte imaginária. Então, um número pode ser eliminado se, quando o colocamos projecte raiseo resultado volta ao tipo com que começamos, terminarmos com algo igual ao que começamos. Mostre como implementar essa ideia em detalhes, escrevendo uma dropfunção que elimine um objeto o mais longe possível. Você precisará projetar as várias operações de projeção [[5]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#footnote-5) e instalar projectcomo uma operação genérica no sistema. Você também precisará fazer uso de um predicado de igualdade genérico, como descrito no exercício [2,79](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.1.html#ex_2.79) . Finalmente, use droppara reescrever a apply_genericpartir do exercício [2,84](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#ex_2.84) para que simplifica suas respostas.

**Exercício 2.86** Suponha que desejemos lidar com números complexos cujas partes reais, partes imaginárias, magnitudes e ângulos podem ser números comuns, números racionais ou outros números que possamos desejar adicionar ao sistema. Descreva e implemente as mudanças no sistema necessárias para acomodar isso. Você terá que definir operações como sinee cosineque são genéricas sobre números comuns e números racionais.

---

[[1]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#footnote-link-1) Também temos que fornecer uma função quase idêntica para lidar com os tipos list("javascript_number", "complex").

[[2]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#footnote-link-2) Veja o exercício [2,82](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#ex_2.82) para generalizações.

[[3]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#footnote-link-3) Se formos inteligentes, geralmente podemos sobreviver com menos de $ n ^ 2 $ funções de coerção. Por exemplo, se sabemos como converter do tipo 1 para o tipo 2 e do tipo 2 para o tipo 3, então podemos usar esse conhecimento para converter do tipo 1 para o tipo 3. Isso pode diminuir muito o número de funções de coerção que precisamos para fornecer explicitamente quando adicionamos um novo tipo ao sistema. Se estivermos dispostos a construir a quantidade necessária de sofisticação em nosso sistema, podemos fazer com que ele pesquise o n2

gráfico de relações entre tipos e gerar automaticamente as funções de coerção que podem ser inferidas daquelas que são fornecidas explicitamente.

[[4]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#footnote-link-4) Esta afirmação, que também aparece na primeira edição deste livro, é tão verdadeira agora quanto era quando a escrevemos em 1984. Desenvolvimento de uma estrutura geral útil para expressar as relações entre diferentes tipos de entidades (o que os filósofos chamam ontologia ) parece extremamente difícil. A principal diferença entre a confusão que existia em 1984 e a confusão que existe agora é que agora uma variedade de teorias ontológicas inadequadas foram incorporadas em uma infinidade de linguagens de programação correspondentemente inadequadas. Por exemplo, grande parte da complexidade das linguagens de programação orientadas a objetos - e as diferenças sutis e confusas entre as linguagens orientadas a objetos contemporâneas - concentra-se no tratamento de operações genéricas em tipos inter-relacionados. Nossa própria discussão sobre objetos computacionais no capítulo 3 evita totalmente essas questões. Os leitores familiarizados com a programação orientada a objetos perceberão que temos muito a dizer no capítulo 3 sobre o estado local, mas nem mesmo mencionamos Aulas ou herança. Na verdade, suspeitamos que esses problemas não podem ser adequadamente tratados em termos de design de linguagem de computador apenas, sem também recorrer ao trabalho de representação do conhecimento e raciocínio automatizado.

[[5]](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.2.html#footnote-link-5) Um número real pode ser projetado para um inteiro usando a math_roundprimitiva, que retorna o inteiro mais próximo de seu argumento.
