2.4.2 Dados marcados

Uma maneira de ver a abstração de dados é como uma aplicação do princípio do mínimo comprometimento. Na implementação do sistema de números complexos na seção [2.4.1](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.4.1.html) , podemos usar a representação retangular de Ben ou a representação polar de Alyssa. A barreira de abstração formada pelos seletores e construtores nos permite adiar até o último momento possível a escolha de uma representação concreta para nossos objetos de dados e, assim, reter o máximo de flexibilidade em nosso design de sistema.

O princípio do mínimo comprometimento pode ser levado a extremos ainda mais distantes. Se quisermos, podemos manter a ambiguidade da representação, mesmo _depois de_ nós projetamos os seletores e construtores, e optar por usar tanto a representação de Ben _e_ representação de Alyssa. Se ambas as representações forem incluídas em um único sistema, entretanto, precisaremos de alguma forma para distinguir os dados na forma polar dos dados na forma retangular. Do contrário, se nos pedissem, por exemplo, que encontrássemos o magnitudedo par (3,4)

, não saberíamos se deveríamos responder 5 (interpretando o número na forma retangular) ou 3 (interpretando o número na forma polar ) Uma maneira direta de realizar essa distinção é incluir uma _tag de tipo_ - a string "rectangular"ou"polar"—Como parte de cada número complexo. Então, quando precisamos manipular um número complexo, podemos usar a tag para decidir qual seletor aplicar.

Para manipular os dados marcados, vamos supor que temos funções type_tage contentsque extraem de um objeto de dados o tag e o conteúdo real (as coordenadas polares ou retangulares, no caso de um número complexo). Também postularemos uma função attach_tagque pega uma tag e conteúdo e produz um objeto de dados com tag. Uma maneira direta de implementar isso é usar uma estrutura de lista comum:

function attach_tag (type_tag, contents) { attach_tag(type_tag, contents) { par de retorno (type_tag, conteúdo);return pair(type_tag, contents); }} function type_tag (datum) {function type_tag(datum) { return is_pair (datum)return is_pair(datum) ? cabeça (datum)? head(datum) : erro (datum, "datum etiquetado incorreto - type_tag");: error(datum, "bad tagged datum -- type_tag"); }} conteúdo da função (datum) {function contents(datum) { return is_pair (datum)return is_pair(datum) ? cauda (datum)? tail(datum) : erro (datum, "datum etiquetado incorreto - conteúdo");: error(datum, "bad tagged datum -- contents"); }}

Usando essas funções, podemos definir predicados is_rectangulare is_polar, que reconhecem números retangulares e polares, respectivamente:

function is_rectangular (z) {is_rectangular ( z ) { return type_tag (z) === "retangular";return type_tag ( z ) === "retangular" ; }} function is_polar (z) {function is_polar ( z ) { return type_tag (z) === "polar";return type_tag ( z ) === "polar" ; }}

Com tags de tipo, Ben e Alyssa agora podem modificar seu código para que suas duas representações diferentes possam coexistir no mesmo sistema. Sempre que Ben constrói um número complexo, ele o marca como retangular. Sempre que Alyssa constrói um número complexo, ela o marca como polar. Além disso, Ben e Alyssa devem se certificar de que os nomes de suas funções não entrem em conflito. Uma maneira de fazer isso é Ben anexar o sufixo rectangularao nome de cada uma de suas funções de representação e Alyssa anexar polaraos nomes dela. Aqui está a representação retangular revisada de Ben da seção [2.4.1](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.4.1.html) :

function real_part_rectangular (z) { real_part_rectangular(z) { cabeça de retorno (z);return head(z); }} function imag_part_rectangular (z) {function imag_part_rectangular(z) { cauda de retorno (z);return tail(z); }} function magnitude_rectangular (z) {function magnitude_rectangular(z) { return math_sqrt (square (real_part_rectangular (z))return math_sqrt(square(real_part_rectangular(z)) ++ quadrado (imag_part_rectangular (z)));(imag_part_rectangular(z))); }} function angle_rectangular (z) {function angle_rectangular(z) { return math_atan (imag_part_rectangular (z),return math_atan(imag_part_rectangular(z), real_part_rectangular (z));(z)); }} function make_from_real_imag_rectangular (x, y) {function make_from_real_imag_rectangular(x, y) { return attach_tag ("retangular",return attach_tag("rectangular", par (x, y));(x, y)); }} function make_from_mag_ang_rectangular (r, a) {function make_from_mag_ang_rectangular(r, a) { return attach_tag ("retangular",return attach_tag("rectangular", pair (r _ math_cos (a), r _ math_sin (a)));(r _ math_cos(a), r _ math_sin(a))); }}

e aqui está a representação polar revisada de Alyssa:

function real_part_polar (z) { real_part_polar(z) { retornar magnitude_polar (z) _ math_cos (ângulo_polar (z));return magnitude_polar(z) _ math_cos(angle_polar(z)); }} function imag_part_polar (z) {function imag_part_polar(z) { retorna magnitude_polar (z) _ math_sin (ângulo_polar (z));return magnitude_polar(z) _ math_sin(angle_polar(z)); }} function magnitude_polar (z) {function magnitude_polar(z) { cabeça de retorno (z);return head(z); }} function angle_polar (z) {function angle_polar(z) { cauda de retorno (z);return tail(z); }} function make_from_real_imag_polar (x, y) {function make_from_real_imag_polar(x, y) { return attach_tag ("polar",return attach_tag("polar", par (math_sqrt (square (x) + square (y)),(math_sqrt(square(x) + square(y)), math_atan (y, x)));(y, x))); }} function make_from_mag_ang_polar (r, a) {function make_from_mag_ang_polar(r, a) { return attach_tag ("polar", pair (r, a));return attach_tag("polar", pair(r, a)); }}

Cada seletor genérico é implementado como uma função que verifica a tag de seu argumento e chama a função apropriada para manipular dados desse tipo. Por exemplo, para obter a parte real de um número complexo, real_partexamina a etiqueta para determinar se deve usar Ben's real_part_rectangularou Alyssa's real_part_polar. Em ambos os casos, usamos contentspara extrair o datum vazio e não marcado e enviá-lo para a função retangular ou polar, conforme necessário:

function real_part (z) { real_part(z) { return is_rectangular (z)return is_rectangular(z) ? real_part_rectangular (conteúdo (z))? real_part_rectangular(contents(z)) : is_polar (z): is_polar(z) ? real_part_polar (conteúdo (z))? real_part_polar(contents(z)) : erro (z, "tipo desconhecido - parte_real");: error(z, "unknown type -- real_part"); }} function imag_part (z) {function imag_part(z) { return is_rectangular (z)return is_rectangular(z) ? imag_part_rectangular (conteúdo (z))? imag_part_rectangular(contents(z)) : is_polar (z): is_polar(z) ? imag_part_polar (conteúdo (z))? imag_part_polar(contents(z)) : erro (z, "tipo desconhecido - parte_imagem");: error(z, "unknown type -- imag_part"); }} magnitude da função (z) {function magnitude(z) { return is_rectangular (z)return is_rectangular(z) ? magnitude_rectangular (conteúdo (z))? magnitude_rectangular(contents(z)) : is_polar (z): is_polar(z) ? magnitude_polar (conteúdo (z))? magnitude_polar(contents(z)) : erro (z, "tipo desconhecido - magnitude");: error(z, "unknown type -- magnitude"); }} ângulo da função (z) {function angle(z) { return is_rectangular (z)return is_rectangular(z) ? ângulo_retangular (conteúdo (z))? angle_rectangular(contents(z)) : is_polar (z): is_polar(z) ? ângulo_polar (conteúdo (z))? angle_polar(contents(z)) : erro (z, "tipo desconhecido - ângulo");: error(z, "unknown type -- angle"); }}

Para implementar as operações aritméticas dos números complexos, podemos usar as mesmas funções add_complex, sub_complex, mul_complexe div_complexda secção [2.4.1](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.4.1.html) , porque os seletores que eles chamam são genéricos e, portanto, funcionarão com qualquer uma das representações. Por exemplo, a função add_complexainda é

function add_complex (z1, z2) {add_complex ( z1 , z2 ) { retornar make_from_real_imag (real_part (z1) + real_part (z2),retornar make_from_real_imag ( real_part ( z1 ) + real_part ( z2 ), imag_part (z1) + imag_part (z2));( z1 ) + parte_imagem ( z2 )); }}

Finalmente, devemos escolher se vamos construir números complexos usando a representação de Ben ou a representação de Alyssa. Uma escolha razoável é construir números retangulares sempre que tivermos partes reais e imaginárias e construir números polares sempre que tivermos magnitudes e ângulos:

function make_from_real_imag (x, y) { make_from_real_imag(x, y) { return make_from_real_imag_rectangular (x, y);return make_from_real_imag_rectangular(x, y); }} function make_from_mag_ang (r, a) {function make_from_mag_ang(r, a) { return make_from_mag_ang_polar (r, a);return make_from_mag_ang_polar(r, a); }}

![](https://source-academy.github.io/sicp/img_javascript/ch2-Z-G-62.svg)

![](https://source-academy.github.io/sicp/img_javascript/ch2-Z-G-62.svg)

**[Figura 2.21](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.4.2.html#fig_2.21)** Estrutura do sistema aritmético complexo genérico.

O sistema de números complexos resultante tem a estrutura mostrada na figura [2,21](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.4.2.html#fig_2.21) . O sistema foi decomposto em três partes relativamente independentes: as operações aritméticas de números complexos, a implementação polar de Alyssa e a implementação retangular de Ben. As implementações polares e retangulares poderiam ter sido escritas por Ben e Alyssa trabalhando separadamente, e ambas podem ser usadas como representações subjacentes por um terceiro programador implementando as funções aritméticas complexas em termos da interface construtor / seletor abstrato.

Uma vez que cada objeto de dados é marcado com seu tipo, os seletores operam nos dados de uma maneira genérica. Ou seja, cada seletor é definido para ter um comportamento que depende do tipo específico de dados aos quais é aplicado. Observe o mecanismo geral para fazer a interface das representações separadas: dentro de uma dada implementação de representação (digamos, o pacote polar de Alyssa), um número complexo é um par não tipado (magnitude, ângulo). Quando um seletor genérico opera em uma série depolardigite, ele remove a tag e passa o conteúdo para o código de Alyssa. Por outro lado, quando Alyssa constrói um número para uso geral, ela o marca com um tipo para que possa ser reconhecido apropriadamente pelas funções de nível superior. Esta disciplina de retirar e anexar tags à medida que os objetos de dados são passados ​​de nível a nível pode ser uma estratégia organizacional importante, como veremos na seção [2,5](https://so45nujb3h4koud7nsjm2lne4u-ac4c6men2g7xr2a-github.translate.goog/sicp/chapters/2.5.html) .
